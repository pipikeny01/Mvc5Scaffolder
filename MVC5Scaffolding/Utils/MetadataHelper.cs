using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Windows;
using Microsoft.AspNet.Scaffolding.Core.Metadata;
using PropertyMetadata = Microsoft.AspNet.Scaffolding.Core.Metadata.PropertyMetadata;

namespace Happy.Scaffolding.MVC.Utils
{
    public class MetadataHelper
    {
        private readonly string _assemblyPath;

        public MetadataHelper(string assemblyPath)
        {
            _assemblyPath = assemblyPath;
        }

        public ModelMetadata ToMetadata(string dbContextTypeName)
        {
            var assembly = LoadAssemblyByNewDomain();

            var modelMetadata = new ModelMetadata();

            var contextType = assembly.GetTypes().FirstOrDefault(p => p.FullName == dbContextTypeName);

            modelMetadata.EntitySetName = contextType.Name;

            var keypropertyMetadatas = new List<PropertyMetadata>();
            var propertyMetadatas = new List<PropertyMetadata>();
            foreach (var propertyInfo in contextType.GetProperties())
            {
                //key
                if (IsKey(propertyInfo))
                {
                    var propertyMetadata = CreateKeyMata(propertyInfo);
                    keypropertyMetadatas.Add(propertyMetadata);
                    propertyMetadatas.Add(propertyMetadata);
                }
                else
                {
                    propertyMetadatas.Add(PropertyMetadata(propertyInfo, false));

                }

            }

            modelMetadata.PrimaryKeys = keypropertyMetadatas.ToArray();
            modelMetadata.Properties = propertyMetadatas.ToArray();

            return modelMetadata;
        }

        private static bool IsKey(PropertyInfo propertyInfo)
        {
            return propertyInfo.Name.ToLower().EndsWith("id") ||
                   propertyInfo.CustomAttributes.Any(attr => attr.AttributeType == typeof(KeyAttribute));
        }

        /// <summary>
        /// Create Domain Load Assembly ,因為Assembly.Load不會Dispose
        /// </summary>
        ///<remarks>https://social.msdn.microsoft.com/Forums/en-US/a6a896ca-8905-41fb-8f52-7f39e89c9a91/problem-loading-and-unloading-dynamically-an-assembly-dll-in-c?forum=csharplanguage</remarks>
        /// <returns></returns>
        private Assembly LoadAssemblyByNewDomain()
        {
            return Assembly.Load(File.ReadAllBytes(_assemblyPath));

            //AppDomain ad = AppDomain.CreateDomain("load" + Guid.NewGuid());

            //MessageBox.Show(typeof(Loader).Assembly.Location);
            //MessageBox.Show(typeof(Loader).FullName);

            //Loader loader = (Loader)ad.CreateInstanceFromAndUnwrap(
            //    typeof(Loader).Assembly.Location,
            //    typeof(Loader).FullName);



            //var assembly = loader.LoadAssembly(_assemblyPath);

            //AppDomain.Unload(ad);

            //return assembly;
        }

        private static PropertyMetadata CreateKeyMata(PropertyInfo key)
        {
            return PropertyMetadata(key, true);
        }

        private static PropertyMetadata PropertyMetadata(PropertyInfo key, bool isPrimaryKey)
        {
            var type = key.PropertyType.GetType();

            return new PropertyMetadata
            {
                AssociationDirection = AssociationDirection.None,
                DefaultValue = null,
                IsAssociation = false,
                IsAutoGenerated = false,
                IsComplexType = false,
                IsConcurrencyProperty = false,
                IsEnum = false,
                IsEnumFlags = false,
                IsForeignKey = false,
                IsIndependentAssociation = false,
                IsPrimaryKey = isPrimaryKey,
                IsReadOnly = false,
                PropertyName = key.Name,
                RelatedModel = null,
                Scaffold = false,
                ShortTypeName = key.PropertyType.ToAliases(),
                TypeName = key.PropertyType.Name
            };
        }

        protected virtual bool IsFileLocked(FileInfo file)
        {
            try
            {
                using (FileStream stream = file.Open(FileMode.Open, FileAccess.Read, FileShare.None))
                {
                    stream.Close();
                }
            }
            catch (IOException)
            {
                //the file is unavailable because it is:
                //still being written to
                //or being processed by another thread
                //or does not exist (has already been processed)
                return true;
            }

            //file is not locked
            return false;
        }

    }

    public class Loader : MarshalByRefObject
    {
        private Assembly _assembly;

        public override object InitializeLifetimeService()
        {
            return null;
        }

        public Assembly LoadAssembly(string path)
        {
            return Assembly.LoadFrom(path);
        }

        public object ExecuteStaticMethod(string typeName, string methodName, params object[] parameters)
        {
            Type type = _assembly.GetType(typeName);
            // TODO: this won't work if there are overloads available
            MethodInfo method = type.GetMethod(
                methodName,
                BindingFlags.Static | BindingFlags.Public);
            return method.Invoke(null, parameters);
        }
    }

}